import sound_direction;

Page test_page
{
    TestItem    titem;           // trial control parameters
    HabItem     hitem;
    
    FaceItem    hfaceitem;       // Faces, we have 4 of them...
    FaceItem    tfaceitem;       // And 4 for tests

    string hab_old_face = "";
    string test_old_face = "";
    
    int token_played_counter;

    init()
    {
        fill_pattern_color = TEST_PAGE_COLOR;
    }
 
    on_event:message()
    {
        if(message_sender == control && message_arg == CLOCK_RUNNING)
        {
            continue_timer.abort();
        }
        else if ( message_sender == control && message_arg == CLOCK_PAUSED)
        {
            continue_timer.start(event_time + LOOKAWAY_CONTINUES_THRESHOLD);
        }
        else
            handle_special_key(this, input_key, input_modifiers);
    }
    
    Timer continue_timer
    {
        on_event:expire()
        {
            control.end_clock(event_time);
            done(CONTINUE, event_time);
        }
    }
 
    VerticalLayout layout
    {
        init()
        {
            spacing = 50;
            height = 0;     // 0 means as large as possible
        }
 
 
        CanvasGadget canvas
        {
            on_event:resize()
            {
                offset_x = floor(test_window1.width / 2);
                offset_y = floor(test_window1.height/ 2);
            }

            ImageShape picture
            {
                void setup(string file_name)
                {
                    picture.image    = stimuli_dir() + "images/" + file_name;
                    picture.offset_x = -floor(picture.actual_width/2);
                    picture.offset_y = -floor(picture.actual_height/2);
                }
            }

            time start_picture(time t, string file_name)
            {
                picture.setup(file_name);
                picture.start(t);
                return picture.expected_start_time;
            }
        }
 
 
        time start_stimulus(time t)
        {
          return t;
        }
 
 
        void reset()
        {
            full_abort();
        }
    }

    bool check_if_we_are_done(time t)
    {
        token_played_counter++;
        if(token_played_counter >= TOKEN_REPETITION_MAX)
        {
            done(CONTINUE, t);
            return true;
        }
        return false;
    }

    

    SoundChain test_audio
    {
        string[..] file_names;

        SoundFile clip {}
     
        SoundPlayback playback {}
       
        on_event:start()
        {
            control.show_speaker_icon(FRONT_SIDE);
        }

        on_event:finish()
        {
            control.hide_speaker_icon(FRONT_SIDE);
            if(!check_if_we_are_done(event_time))
                this.play(
                        event_time + INTERSOUND_INTERVAL,
                        SND_DIRECTION_FRONT
                        );
        }

        time play(time t, SoundDirection dir)
        {
            this.playback.device = sound_output_device;
            this.clip.file = stimuli_dir() + "sounds/" + 
                             test_audio.file_names[0];
            first_to_last_shift(file_names);

            // mute all channels.
            playback.set_scaling(0.0);

            if (dir & SND_DIRECTION_FRONT) {
                playback.set_scaling(CHANNEL_FRONT_LEFT,  1.0);
                playback.set_scaling(CHANNEL_FRONT_RIGHT, 1.0);
            }
            else {
                playback.set_scaling(CHANNEL_FRONT_LEFT,  0.0);
                playback.set_scaling(CHANNEL_FRONT_RIGHT, 0.0);
            }

            if (dir & SND_DIRECTION_LEFT)
                playback.set_scaling(CHANNEL_REAR_LEFT, 1.0);
            else
                playback.set_scaling(CHANNEL_REAR_LEFT, 0.0);
            
            if (dir & SND_DIRECTION_RIGHT)
                playback.set_scaling(CHANNEL_REAR_RIGHT, 1.0);
            else
                playback.set_scaling(CHANNEL_REAR_RIGHT, 0.0);


            this.start(t);
            return test_audio.expected_start_time;
        }

        void setup()
        {
            test_audio.abort();

            file_names.size = 2;
            file_names[0] = titem.sound1_filename;
            file_names[1] = titem.sound2_filename;
        }

        void first_to_last_shift(string[] array)
        {
            int index;
            string first = array[index];

            while(index < array.size-1)
            {
                array[index] = array[index+1];
                index++;
            }

            array[array.size-1] = first;
        }
        
    }
 
  SoundChain hab_audio
    {
        string[..] hab_file_names;

        int snd_index = 0;

        //bool is_hab_item;

        SoundFile clip {}
     
        SoundPlayback playback {}
       
        on_event:start()
        {
            control.show_speaker_icon(FRONT_SIDE);
        }

        on_event:finish()
        {
            control.hide_speaker_icon(FRONT_SIDE);
            if(!check_if_we_are_done(event_time))
                this.play(
                        event_time + INTERSOUND_INTERVAL,
                        SND_DIRECTION_FRONT
                        );
        }

        time play(time t, SoundDirection dir)
        {
            this.playback.device = sound_output_device;
            if (snd_index >= hab_file_names.size)
                print_error("Oops, trying to present a file greater than "
                    "the number of hab_face_items.size"
                    );
            this.clip.file =stimuli_dir() + "sounds/" +
                hab_file_names[snd_index % hab_file_names.size];
            snd_index++;

            // mute all channels.
            playback.set_scaling(0.0);

            if (dir & SND_DIRECTION_FRONT) {
                playback.set_scaling(CHANNEL_FRONT_LEFT,  1.0);
                playback.set_scaling(CHANNEL_FRONT_RIGHT, 1.0);
            }
            else {
                playback.set_scaling(CHANNEL_FRONT_LEFT,  0.0);
                playback.set_scaling(CHANNEL_FRONT_RIGHT, 0.0);
            }

            if (dir & SND_DIRECTION_LEFT)
                playback.set_scaling(CHANNEL_REAR_LEFT, 1.0);
            else
                playback.set_scaling(CHANNEL_REAR_LEFT, 0.0);
            
            if (dir & SND_DIRECTION_RIGHT)
                playback.set_scaling(CHANNEL_REAR_RIGHT, 1.0);
            else
                playback.set_scaling(CHANNEL_REAR_RIGHT, 0.0);


            this.start(t);
            return hab_audio.expected_start_time;
        }

        void setup()
        {
            snd_index = 0;
            hab_audio.abort();
            hab_file_names.size = 12;
            hab_file_names[0] = hitem.sound1_filename;
            hab_file_names[1] = hitem.sound2_filename;
            hab_file_names[2] = hitem.sound3_filename;
            hab_file_names[3] = hitem.sound4_filename;
            hab_file_names[4] = hitem.sound5_filename;
            hab_file_names[5] = hitem.sound6_filename;
            hab_file_names[6] = hitem.sound7_filename;
            hab_file_names[7] = hitem.sound8_filename;
            hab_file_names[8] = hitem.sound9_filename;
            hab_file_names[9] = hitem.sound10_filename;
            hab_file_names[10] = hitem.sound11_filename;
            hab_file_names[11] = hitem.sound12_filename; 

            hab_file_names.shuffle(1, -1); //we only shuffle the remaining 11 items, see .csv file examples
   
            println (">>> audio 0: " + hab_file_names[0]);
            println (">>> audio 1: " + hab_file_names[1]);
            println (">>> audio 2: " + hab_file_names[2]);
            println (">>> audio 3: " + hab_file_names[3]);            
            println (">>> audio 4: " + hab_file_names[4]);
            println (">>> audio 5: " + hab_file_names[5]);
            println (">>> audio 6: " + hab_file_names[6]);
            println (">>> audio 7: " + hab_file_names[7]);
            println (">>> audio 8: " + hab_file_names[8]);
            println (">>> audio 9: " + hab_file_names[9]);
            println (">>> audio10: " + hab_file_names[10]);
            println (">>> audio11: " + hab_file_names[11]);            
        }
    }

    // Aborts any ongoing activity on this page and signals the initiator
    // of the trial that we're done.
    void done(int msgid, time t)
    {
        // Just in case; abort presentation if still active.
        layout.reset();
        hab_audio.abort();

        signal_target(msgid);   // tell caller we're done
        target = null;
 
        control.stop_clock(t);
        control.clear_status();
        control.controlled_page = null;
    }
 
 
    //==========================================================================
 
 
    // Performs preparatory work required before using this page.
    void hab_setup()
    { 
    }
 
     void test_setup()
    { 
    }

    // Performs cleaning up if necessary.
    void cleanup()
    {
        control.clear_status();

        // Just in case; abort presentation if still active.
        layout.reset();
        hab_audio.abort();
        test_audio.abort();
    }

    // select the picture to be used
    void set_hab_face() 
    { 
        // select one    
        int n = random(0, hab_face_items.size - 1);
        println(hab_face_items.size);
        while (hab_face_items[n].face_filename == hab_old_face)
        {
            n = random(0, hab_face_items.size - 1);         
        }
        hfaceitem = hab_face_items[n];
        hab_old_face = hab_face_items[n].face_filename;
    }
                
    // select the picture to be used
    void set_test_face() 
    { 
        // select one    
        int n = random(0, test_face_items.size - 1);
        println(test_face_items.size);
        while (test_face_items[n].face_filename == test_old_face)
        {
            n = random(0, test_face_items.size - 1);         
        }
        tfaceitem = test_face_items[n];
        test_old_face = test_face_items[n].face_filename;
    }
                              
    // Starts a hab trial.
    void hab_action(Object caller, HabItem it, time tref)
    {

        //setup control boxes
        experiment.setup_response_box();
        control.controlled_page = this;

        token_played_counter = 0;

        // Save the passed trial control parameters.

        hitem = it;

        // println(item);
        
        //and the faces separately
        set_hab_face(); 
 
        // Show this page (if not yet done) and make tref the trial start time.
        tref = test_window1.show_test_page(this, tref);

        tref = layout.canvas.start_picture(tref, hfaceitem.face_filename);
        
        hab_audio.setup();
        
        tref = hab_audio.play(tref, SND_DIRECTION_FRONT);

        // control
        control.begin_clock();
        control.release_clock(tref);
        control.start_clock(tref);

        // Remember who to signal when the trial is over.
        target = caller;

        // Update status line on control window. Cleared in done() above.
        control.set_status(
            string(hitem.id) + "  " + 
            string(hfaceitem.face_filename));
    }

        // Starts a hab trial.
    void test_action(Object caller, TestItem it, time tref)
    {

        //setup control boxes
        experiment.setup_response_box();
        control.controlled_page = this;

        token_played_counter = 0;

        // Save the passed trial control parameters.

        titem = it;
      
        //and the faces separately
        set_test_face(); 
 
        // Show this page (if not yet done) and make tref the trial start time.
        tref = test_window1.show_test_page(this, tref);

        tref = layout.canvas.start_picture(tref, tfaceitem.face_filename);
        test_audio.setup();
        tref = test_audio.play(tref, SND_DIRECTION_FRONT);

        // control
        control.begin_clock();
        control.release_clock(tref);
        control.start_clock(tref);

        // Remember who to signal when the trial is over.
        target = caller;


        // Update status line on control window. Cleared in done() above.
        control.set_status(
            string(titem.id) + "  " + 
            string(tfaceitem.face_filename));
    }
}
